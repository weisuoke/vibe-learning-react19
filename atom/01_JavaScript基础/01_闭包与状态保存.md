# 闭包与状态保存

## 一、【30字核心】

**闭包是函数和其词法环境的组合，能在外部函数执行后保持对其作用域的引用，是 React Hooks 状态保存的核心机制。**

---

## 二、【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 闭包的第一性原理 🎯

#### 1. 最基础的定义

**闭包 = 函数 + 词法环境**

仅此而已！没有更基础的了。

当一个函数被创建时，它会"记住"它被定义时的作用域环境。即使这个环境已经消失了（比如外部函数已经执行完毕），内部函数仍然能访问那些变量。

#### 2. 为什么需要闭包？

**核心问题：JavaScript 执行栈销毁后如何保持数据？**

JavaScript 的函数执行完毕后，它的执行上下文会被销毁，局部变量也会被垃圾回收。但实际开发中，我们经常需要：
- 保存函数执行后的状态
- 实现数据私有化
- 延迟计算和执行

如果没有闭包，我们只能用全局变量来保存数据，这会导致命名冲突、数据污染等问题。

#### 3. 闭包的三层价值

##### 价值1：数据私有化 🔒

闭包可以创建私有变量，外部无法直接访问，只能通过闭包提供的函数接口操作。

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // 私有变量

  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return '余额不足';
    },
    getBalance() {
      return balance;
    }
  };
}

const myAccount = createBankAccount(1000);
console.log(myAccount.getBalance()); // 1000
myAccount.deposit(500);             // 1500
console.log(myAccount.balance);      // undefined (无法直接访问)
```

##### 价值2：状态持久化 💾

闭包可以在函数调用之间保持状态，这是 React Hooks 的基础。

```javascript
function createCounter() {
  let count = 0; // 状态持久化

  return function increment() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
// count 一直被保留在内存中
```

##### 价值3：延迟执行与柯里化 ⏱️

闭包可以实现参数的部分应用和延迟执行。

```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const multiplyByTwo = multiply(2);
console.log(multiplyByTwo(5));  // 10
console.log(multiplyByTwo(10)); // 20
// a 的值被闭包保存，可以复用
```

#### 4. 从第一性原理推导 React 实现

**推理链：**

```
1. React 需要在组件重新渲染时保存状态
   ↓
2. 函数组件每次执行都是全新的执行上下文
   ↓
3. 局部变量会被销毁，无法保存状态
   ↓
4. 需要一个机制在组件外部保存数据
   ↓
5. 使用闭包：Hook 函数访问 Fiber 节点上的状态
   ↓
6. 每次渲染时，Hook 通过闭包读取/更新状态
   ↓
7. 实现了 useState、useEffect 等 Hooks
   ↓
8. 函数组件拥有了状态管理能力
```

**为什么 React 选择闭包？**

- **自然的函数式编程范式**：符合 React 的声明式理念
- **无需 this 绑定**：避免了 class 组件的 this 陷阱
- **状态隔离**：每个组件实例的状态独立
- **轻量级**：不需要额外的状态管理库

#### 5. 一句话总结第一性原理

**闭包是通过词法作用域机制让函数保持对其定义环境的引用，从而实现数据私有化、状态持久化和延迟执行，是 JavaScript 函数式编程的基石。**

---

## 三、【3个核心概念】

### 核心概念1：词法作用域（Lexical Scope） 📐

**词法作用域是指函数的作用域在函数定义时就已经确定，而不是在函数调用时确定。**

```javascript
const globalVar = 'global';

function outerFunction() {
  const outerVar = 'outer';

  function innerFunction() {
    const innerVar = 'inner';
    console.log(innerVar);   // 访问自己的变量
    console.log(outerVar);   // 访问外部函数的变量
    console.log(globalVar);  // 访问全局变量
  }

  innerFunction();
}

outerFunction();
// 输出:
// inner
// outer
// global
```

**详细解释：**

词法作用域也叫静态作用域，它的查找规则是：
1. 首先在当前作用域查找变量
2. 如果找不到，去外层作用域查找
3. 一层层向上查找，直到全局作用域
4. 如果全局作用域也找不到，则报错

**关键点**：这个查找路径是在**代码编写时**就确定的，而不是在运行时。

**在 React 源码/开发中的应用：**

React Hooks 依赖词法作用域来访问组件的 props 和状态：

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    // handleClick 可以访问 count，因为它们在同一个词法作用域
    setCount(count + 1);
  }

  return <button onClick={handleClick}>{count}</button>;
}
```

### 核心概念2：作用域链（Scope Chain） 🔗

**作用域链是 JavaScript 引擎查找变量时遵循的查找路径，由当前作用域及其所有外层作用域组成。**

```javascript
const level1 = 'Level 1';

function layer1() {
  const level2 = 'Level 2';

  function layer2() {
    const level3 = 'Level 3';

    function layer3() {
      const level4 = 'Level 4';

      // 作用域链：layer3 -> layer2 -> layer1 -> global
      console.log(level4); // 当前作用域
      console.log(level3); // 上1层
      console.log(level2); // 上2层
      console.log(level1); // 上3层（全局）
    }

    layer3();
  }

  layer2();
}

layer1();
```

**作用域链的可视化：**

```
layer3作用域: { level4 }
    ↓ (链接到外层)
layer2作用域: { level3 }
    ↓
layer1作用域: { level2 }
    ↓
global作用域: { level1 }
```

**在 React 源码/开发中的应用：**

React Hooks 的依赖项会通过作用域链被捕获：

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // 这个函数的作用域链：
    // Effect函数 -> UserProfile组件 -> 全局
    // 因此可以访问 userId 和 setUser
    fetchUser(userId).then(data => {
      setUser(data);
    });
  }, [userId]); // userId 通过作用域链被访问

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

**闭包陷阱示例：**

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      // 这里捕获的是初始的 count (0)
      // 形成了"过时闭包"
      console.log(count); // 永远输出 0
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### 核心概念3：垃圾回收与引用保持（GC & Reference Retention） 💾

**闭包会阻止被引用的变量被垃圾回收，从而实现状态的持久化。**

```javascript
function createHeavyObject() {
  const largeData = new Array(1000000).fill('data'); // 大约 4MB

  // 情况1：没有闭包，largeData 会被回收
  function case1() {
    return 'done';
  }

  // 情况2：有闭包，largeData 不会被回收
  function case2() {
    return largeData.length;
  }

  return case2; // 返回了引用 largeData 的函数
}

const fn = createHeavyObject();
// 此时 createHeavyObject 执行完毕
// 但 largeData 不会被回收，因为 fn 还在引用它
```

**垃圾回收的判断依据：**

```javascript
function demo() {
  let a = 1; // 会被回收
  let b = 2; // 不会被回收
  let c = 3; // 会被回收

  function inner() {
    console.log(b); // 只引用了 b
  }

  return inner;
}

const myFunc = demo();
// a 和 c 没有被闭包引用，会被 GC 回收
// b 被闭包引用，不会被回收
```

**在 React 源码/开发中的应用：**

React Hooks 利用闭包保持状态：

```javascript
// React 源码简化版
function mountState(initialState) {
  // 在 Fiber 节点上创建 Hook 对象
  const hook = {
    memoizedState: initialState,
    queue: null,
  };

  // 这个 dispatch 函数形成闭包
  const dispatch = (action) => {
    // 通过闭包访问 hook 对象
    hook.memoizedState = action;
    // 触发重新渲染
    scheduleUpdate();
  };

  return [hook.memoizedState, dispatch];
}

// 使用时
function Component() {
  const [count, setCount] = useState(0);
  // setCount 函数内部的闭包保持了对 hook 对象的引用
  // 因此 count 的值在渲染之间得以保存
}
```

**内存管理最佳实践：**

```javascript
function EventComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const handleScroll = () => {
      console.log(count); // 闭包引用了 count
    };

    window.addEventListener('scroll', handleScroll);

    // ✅ 清理函数移除事件监听器
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
    // 如果不清理，handleScroll 会一直保持对组件状态的引用
  }, [count]);
}
```

---

## 四、【最小可用】

掌握以下内容，就能理解 React 源码核心：

### 4.1 基本闭包模式：函数返回函数

```javascript
// 最简单的闭包
function outer() {
  const message = 'Hello';

  function inner() {
    console.log(message); // 访问外部变量
  }

  return inner;
}

const myFunc = outer();
myFunc(); // 输出: Hello
```

**关键点：**
- `inner` 函数在 `outer` 执行完后仍能访问 `message`
- 这就是闭包的本质

### 4.2 闭包中的变量共享

```javascript
function createCounter() {
  let count = 0;

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
// 三个方法共享同一个 count 变量
```

**关键点：**
- 多个闭包可以访问同一个变量
- 修改会反映在所有闭包中

### 4.3 循环中的闭包陷阱

```javascript
// ❌ 错误示例（使用 var）
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 全部输出 3
  }, 1000);
}

// ✅ 解决方案1：使用 let
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 输出 0, 1, 2
  }, 1000);
}

// ✅ 解决方案2：使用 IIFE
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j); // 输出 0, 1, 2
    }, 1000);
  })(i);
}
```

### 4.4 React useState 的闭包实现原理

```javascript
// 模拟 React 的 Hooks 实现
let currentComponent = null;
let currentHookIndex = 0;

function renderComponent(component) {
  currentHookIndex = 0;
  currentComponent = component;
  return component.render();
}

function useState(initialValue) {
  // 获取当前组件
  const component = currentComponent;
  const hookIndex = currentHookIndex;

  // 初始化 state
  if (!component.hooks) {
    component.hooks = [];
  }
  if (component.hooks[hookIndex] === undefined) {
    component.hooks[hookIndex] = initialValue;
  }

  // setState 函数（闭包）
  const setState = (newValue) => {
    component.hooks[hookIndex] = newValue;
    // 触发重新渲染
    renderComponent(component);
  };

  currentHookIndex++;
  return [component.hooks[hookIndex], setState];
}

// 使用示例
const Counter = {
  render() {
    const [count, setCount] = useState(0);
    console.log(`Count: ${count}`);
    return { count, setCount };
  }
};

const result1 = renderComponent(Counter); // Count: 0
result1.setCount(1);                      // Count: 1
```

**这些知识足以：**
- 理解 React Hooks 的状态保存机制
- 避免常见的闭包陷阱（循环、过时闭包）
- 正确使用 useEffect 的依赖数组
- 为深入学习 Fiber 架构打下基础

---

## 五、【1个类比】

### 类比1：闭包 = 保险箱 🏦

**解释相似性：**

想象你去银行办理保险箱业务：

1. **制造保险箱的过程** = 外部函数执行
   - 银行工作人员给你分配一个保险箱
   - 在里面放入你的贵重物品
   - 给你一把钥匙

2. **你拿着钥匙离开** = 返回内部函数
   - 工作人员下班了（外部函数执行完毕）
   - 但保险箱还在（变量不被回收）
   - 你的钥匙可以随时打开保险箱（闭包访问变量）

**举例：**

```javascript
// 银行创建保险箱
function createSafeBox(initialValue) {
  let treasure = initialValue; // 保险箱里的物品

  // 返回钥匙（函数）
  return {
    viewTreasure() {
      console.log(`保险箱里有：${treasure}`);
      return treasure;
    },
    addTreasure(item) {
      treasure += `, ${item}`;
      console.log(`添加物品后：${treasure}`);
    }
  };
}

// 办理保险箱业务
const mySafeBox = createSafeBox('黄金');

// 使用钥匙访问
mySafeBox.viewTreasure();      // 保险箱里有：黄金
mySafeBox.addTreasure('钻石');  // 添加物品后：黄金, 钻石
mySafeBox.viewTreasure();      // 保险箱里有：黄金, 钻石

// 即使银行工作人员（createSafeBox）早就下班了
// 你仍然可以用钥匙（mySafeBox）访问保险箱（treasure）
```

---

### 类比2：React Hook 状态 = 银行账户 💰

**解释相似性：**

把 React 组件想象成你去银行办业务：

1. **Hook 函数** = 银行柜员
   - 每次渲染都是"去银行"
   - Hook 帮你查询/修改账户（状态）

2. **闭包变量** = 你的账户余额
   - 存在银行系统中（Fiber 节点）
   - 你走了余额还在（状态持久化）

3. **setState** = 存款/取款操作
   - 修改余额
   - 触发对账单更新（重新渲染）

**举例：**

```javascript
// 银行账户系统
function BankAccount() {
  const [balance, setBalance] = useState(1000); // 账户余额

  const deposit = (amount) => {
    // 闭包访问 balance
    const newBalance = balance + amount;
    setBalance(newBalance);
    console.log(`存入 ${amount}，当前余额：${newBalance}`);
  };

  const withdraw = (amount) => {
    if (balance >= amount) {
      const newBalance = balance - amount;
      setBalance(newBalance);
      console.log(`取出 ${amount}，当前余额：${newBalance}`);
    } else {
      console.log('余额不足');
    }
  };

  // 每次"去银行"（组件渲染）
  // Hook 都会告诉你当前余额
  return { balance, deposit, withdraw };
}
```

---

### 类比3：闭包陷阱 = 旧照片 📸

**解释相似性：**

过时闭包就像你手里拿着一张旧照片：

```javascript
function PhotoAlbum() {
  const [age, setAge] = useState(18);

  useEffect(() => {
    // 这里拍了一张"照片"，记录了当前 age = 18
    const timer = setInterval(() => {
      console.log(`照片上的年龄：${age}`); // 永远是 18
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖 = 只拍一次照片

  // 实际年龄在变化
  return (
    <button onClick={() => setAge(age + 1)}>
      实际年龄：{age}
    </button>
  );
}
```

你在 18 岁时拍了一张照片，即使你现在 25 岁了，照片上还是 18 岁的你。

**解决方案**：每次年龄变化时重新拍照（添加依赖）

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log(`最新照片的年龄：${age}`);
  }, 1000);

  return () => clearInterval(timer);
}, [age]); // 每次 age 变化就重新拍照
```

---

### 类比总结表

| React 概念 | 生活场景类比 | 相似点 |
|-----------|------------|--------|
| 外部函数 | 保险箱制造过程 | 创建环境和初始值 |
| 内部函数 | 保险箱钥匙 | 访问被保护数据的凭证 |
| 闭包变量 | 保险箱里的物品 | 被保护、持久化的数据 |
| Hook 状态 | 银行账户余额 | 在外部系统中持久化存储 |
| setState | 存款/取款 | 修改状态并触发更新 |
| 过时闭包 | 旧照片 | 捕获的是过去的快照 |
| 依赖数组 | 重新拍照 | 更新闭包捕获的值 |

---

## 六、【反直觉点】

### 误区1：闭包会导致内存泄漏 ❌

**为什么错？**

闭包本身不会导致内存泄漏。内存泄漏是由于：
- 闭包引用了不再需要的变量
- 忘记清理事件监听器或定时器
- 创建了不会被垃圾回收的引用链

**为什么人们容易这样错？**

因为闭包确实会让变量保持在内存中不被回收，这让人误以为闭包 = 内存泄漏。但实际上，只要合理使用，闭包是安全的。

**正确理解：**

```javascript
// ❌ 这才是内存泄漏（忘记清理）
function MemoryLeak() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count);
    }, 1000);

    // 没有清理定时器！
    // 组件卸载后，timer 还在运行
    // 闭包还在引用组件的 state
  }, []);

  return <div>{count}</div>;
}

// ✅ 正确做法
function NoMemoryLeak() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count);
    }, 1000);

    // 清理定时器
    return () => {
      clearInterval(timer);
    };
  }, [count]);

  return <div>{count}</div>;
}
```

**区分正常的闭包和内存泄漏：**

| 特征 | 正常闭包 | 内存泄漏 |
|-----|---------|---------|
| 引用是否需要 | 需要 | 不再需要但未清理 |
| 能否被回收 | 可以（引用断开时） | 不能（忘记清理） |
| 典型场景 | Hook 状态、事件处理 | 忘记移除监听器 |

---

### 误区2：循环中的闭包都指向同一个变量 ❌

**为什么错？**

只有使用 `var` 声明时才会出现这个问题。使用 `let` 或 `const` 声明，每次循环都会创建新的变量。

**为什么人们容易这样错？**

这是 JavaScript 历史遗留问题。在 ES6 之前只有 `var`，它没有块级作用域，导致循环中的闭包都指向同一个变量。很多人学习时接触的是旧代码，形成了错误认知。

**正确理解：**

```javascript
// ❌ 使用 var（错误示例）
console.log('=== 使用 var ===');
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 全部输出 3
  }, 1000);
}
// 原因：var 没有块级作用域，三个闭包都引用同一个 i

// ✅ 使用 let（正确）
console.log('=== 使用 let ===');
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 输出 0, 1, 2
  }, 1000);
}
// 原因：let 有块级作用域，每次循环都创建新的 i

// ✅ 使用 IIFE（兼容旧代码）
console.log('=== 使用 IIFE ===');
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j); // 输出 0, 1, 2
    }, 1000);
  })(i);
}
// 原因：IIFE 创建了新的作用域，j 是新变量
```

**在 React 中的应用：**

```javascript
// ❌ 错误：在循环中创建事件处理器
function TodoList({ todos }) {
  const handlers = [];

  for (var i = 0; i < todos.length; i++) {
    handlers.push(() => {
      console.log(i); // 全部都是最后一个索引
      deleteTodo(i);
    });
  }

  return todos.map((todo, index) => (
    <button onClick={handlers[index]}>{todo}</button>
  ));
}

// ✅ 正确：使用函数参数或 let
function TodoList({ todos }) {
  return todos.map((todo, index) => (
    <button onClick={() => deleteTodo(index)}>
      {todo}
    </button>
  ));
}
```

---

### 误区3：每次 render 都创建新闭包会很慢 ❌

**为什么错？**

现代 JavaScript 引擎对函数创建进行了高度优化，创建闭包的开销非常小。React 也提供了 `useCallback` 和 `useMemo` 来避免不必要的重新创建。

**为什么人们容易这样错？**

因为看到 React 组件每次渲染都会创建新的函数，直觉上认为这会影响性能。但实际上，过早优化才是万恶之源。

**正确理解：**

```javascript
// 大多数情况下，这样就够了
function Counter() {
  const [count, setCount] = useState(0);

  // 每次渲染都创建新的 handleClick
  // 这完全没问题！
  const handleClick = () => {
    setCount(count + 1);
  };

  return <button onClick={handleClick}>{count}</button>;
}

// 只有在以下情况才需要优化：
// 1. 传给经过 React.memo 优化的子组件
// 2. 作为 useEffect 的依赖项
// 3. 函数内部有复杂计算

function OptimizedCounter() {
  const [count, setCount] = useState(0);

  // 使用 useCallback 优化
  const handleClick = useCallback(() => {
    setCount(c => c + 1); // 使用函数式更新
  }, []); // 空依赖，函数永远不变

  return <MemoizedButton onClick={handleClick}>{count}</MemoizedButton>;
}

const MemoizedButton = React.memo(({ onClick, children }) => {
  console.log('Button rendered');
  return <button onClick={onClick}>{children}</button>;
});
```

**性能对比：**

```javascript
// 测试：创建 10000 个闭包的耗时
console.time('创建闭包');
for (let i = 0; i < 10000; i++) {
  const closure = () => {
    return i;
  };
}
console.timeEnd('创建闭包');
// 通常只需要 1-2 毫秒

// React 的建议：
// 1. 先让代码正确运行
// 2. 再用 DevTools 找性能瓶颈
// 3. 只优化真正的瓶颈
```

**记住：**
- ✅ 闭包开销很小，不要过早优化
- ✅ 使用 `useCallback` 时也要考虑成本（依赖数组比较也有开销）
- ✅ 性能问题大多来自不必要的渲染，而非闭包创建

---

## 七、【实战代码】

### 基础实现（简化版）

```javascript
// ===== 1. 场景1：经典闭包 =====
console.log("=== 场景1：经典闭包 ===");

function createCounter() {
  let count = 0; // 私有变量

  return {
    increment() {
      count++;
      console.log(`递增后：${count}`);
      return count;
    },
    decrement() {
      count--;
      console.log(`递减后：${count}`);
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter1 = createCounter();
counter1.increment(); // 递增后：1
counter1.increment(); // 递增后：2
counter1.decrement(); // 递减后：1
console.log(`当前计数：${counter1.getCount()}`); // 当前计数：1
console.log(`能否直接访问 count？`, counter1.count); // undefined

// ===== 2. 场景2：模拟 useState =====
console.log("\n=== 场景2：模拟 useState ===");

function createState(initialValue) {
  let state = initialValue; // 闭包保存的状态

  function getState() {
    return state;
  }

  function setState(newValue) {
    state = typeof newValue === 'function'
      ? newValue(state)  // 支持函数式更新
      : newValue;
    console.log(`状态更新为：${state}`);
  }

  return [getState, setState];
}

const [getCount, setCount] = createState(0);
console.log(`初始状态：${getCount()}`);    // 初始状态：0
setCount(1);                              // 状态更新为：1
setCount(count => count + 1);             // 状态更新为：2
console.log(`最终状态：${getCount()}`);    // 最终状态：2

// ===== 3. 场景3：循环中的闭包（对比 var 和 let） =====
console.log("\n=== 场景3：循环中的闭包 ===");

console.log("使用 var（错误示例）：");
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(`var i = ${i}`); // 全部输出 3
  }, 100);
}

setTimeout(() => {
  console.log("\n使用 let（正确示例）：");
  for (let j = 0; j < 3; j++) {
    setTimeout(() => {
      console.log(`let j = ${j}`); // 输出 0, 1, 2
    }, 100);
  }
}, 200);

// ===== 4. 场景4：闭包实现私有属性 =====
console.log("\n=== 场景4：闭包实现私有属性 ===");

function Person(name, age) {
  // 私有变量
  let _name = name;
  let _age = age;

  // 公共方法（闭包）
  this.getName = function() {
    return _name;
  };

  this.getAge = function() {
    return _age;
  };

  this.setAge = function(newAge) {
    if (newAge > 0 && newAge < 150) {
      _age = newAge;
      console.log(`年龄已更新为：${_age}`);
    } else {
      console.log('年龄不合法');
    }
  };

  this.introduce = function() {
    console.log(`我叫${_name}，今年${_age}岁`);
  };
}

const person = new Person('张三', 25);
person.introduce();              // 我叫张三，今年25岁
person.setAge(30);              // 年龄已更新为：30
person.introduce();              // 我叫张三，今年30岁
console.log('能否直接访问 _age？', person._age); // undefined

// ===== 5. 场景5：函数柯里化 =====
console.log("\n=== 场景5：函数柯里化 ===");

function multiply(a) {
  return function(b) {
    return function(c) {
      const result = a * b * c;
      console.log(`${a} × ${b} × ${c} = ${result}`);
      return result;
    };
  };
}

const multiplyBy2 = multiply(2);
const multiplyBy2And3 = multiplyBy2(3);
multiplyBy2And3(4);  // 2 × 3 × 4 = 24
multiply(2)(3)(4);   // 2 × 3 × 4 = 24（链式调用）
```

### 运行输出示例：

```
=== 场景1：经典闭包 ===
递增后：1
递增后：2
递减后：1
当前计数：1
能否直接访问 count？ undefined

=== 场景2：模拟 useState ===
初始状态：0
状态更新为：1
状态更新为：2
最终状态：2

=== 场景3：循环中的闭包 ===
使用 var（错误示例）：
var i = 3
var i = 3
var i = 3

使用 let（正确示例）：
let j = 0
let j = 1
let j = 2

=== 场景4：闭包实现私有属性 ===
我叫张三，今年25岁
年龄已更新为：30
我叫张三，今年30岁
能否直接访问 _age？ undefined

=== 场景5：函数柯里化 ===
2 × 3 × 4 = 24
2 × 3 × 4 = 24
```

---

### 进阶：React 源码实现

```javascript
// packages/react-reconciler/src/ReactFiberHooks.js（简化版）

// 当前正在渲染的 Fiber 节点
let currentlyRenderingFiber = null;
// 当前正在处理的 Hook
let currentHook = null;
// 工作中的 Hook
let workInProgressHook = null;

// Hook 对象结构
// {
//   memoizedState: any,        // 保存的状态
//   baseState: any,           // 基础状态
//   queue: UpdateQueue,       // 更新队列
//   next: Hook | null        // 下一个 Hook
// }

function mountState(initialState) {
  // 创建新的 Hook 对象
  const hook = mountWorkInProgressHook();

  // 初始化状态
  if (typeof initialState === 'function') {
    initialState = initialState();
  }
  hook.memoizedState = hook.baseState = initialState;

  // 创建更新队列
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
  });

  // 创建 dispatch 函数（关键：这里形成闭包）
  const dispatch = (queue.dispatch = dispatchAction.bind(
    null,
    currentlyRenderingFiber,  // 闭包捕获当前 Fiber
    queue                     // 闭包捕获队列
  ));

  // 返回状态和更新函数
  return [hook.memoizedState, dispatch];
}

function dispatchAction(fiber, queue, action) {
  // 通过闭包访问 fiber 和 queue
  const update = {
    action,
    next: null,
  };

  // 将更新加入队列
  const pending = queue.pending;
  if (pending === null) {
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  queue.pending = update;

  // 调度更新
  scheduleUpdateOnFiber(fiber);
}

function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    baseState: null,
    queue: null,
    next: null,
  };

  if (workInProgressHook === null) {
    // 第一个 Hook
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // 后续的 Hook，形成链表
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}

// ===== 使用示例 =====

// 模拟组件渲染
function Counter() {
  // 第一次调用 mountState
  const [count, setCount] = mountState(0);

  // setCount 函数通过闭包访问：
  // 1. currentlyRenderingFiber（Counter 的 Fiber 节点）
  // 2. queue（这个 Hook 的更新队列）

  console.log(`Count: ${count}`);

  // 点击按钮时
  setTimeout(() => {
    setCount(1); // 通过闭包找到对应的 Fiber 和队列
  }, 1000);
}
```

**闭包在 React Hooks 中的三个关键作用：**

1. **状态保存**：Hook 状态存储在 Fiber 节点的 `memoizedState` 链表中，通过闭包访问

2. **更新定位**：`dispatch` 函数通过闭包记住了对应的 Fiber 和队列，能准确找到要更新的状态

3. **组件隔离**：每个组件实例的 Hook 闭包都指向不同的 Fiber 节点，状态互不干扰

---

## 八、【面试必问】

### 问题1："请解释闭包的原理，并说说在 React 中的应用"

**普通回答（❌ 不出彩）：**

"闭包就是函数可以访问外部变量。React Hooks 用闭包保存状态。"

**出彩回答（✅ 推荐）：**

> **闭包有三层含义：**
>
> 1. **定义层面**：闭包是函数和其词法环境的组合。当函数被创建时，它会捕获定义时所在作用域的变量引用。
>
> 2. **原理层面**：JavaScript 通过作用域链实现闭包。当内部函数引用了外部变量时，这些变量不会被垃圾回收，从而实现了状态持久化。
>
> 3. **实现层面**：引擎在创建函数时，会将被引用的外部变量保存在函数对象的 `[[Environment]]` 内部属性中。
>
> **在 React 中的核心应用**：
>
> - **useState**：dispatch 函数通过闭包记住了对应的 Fiber 节点和更新队列，实现了状态的准确更新
> - **useEffect**：effect 函数通过闭包捕获了组件的 props 和 state，在异步执行时仍能访问
> - **useCallback**：返回的记忆化函数通过闭包保持对依赖项的引用
>
> **注意事项**：
>
> - 需要正确设置依赖数组，避免"过时闭包"问题
> - 及时清理事件监听器和定时器，避免内存泄漏
> - 利用函数式更新（`setState(prev => prev + 1)`）来避免闭包陷阱

**为什么这个回答出彩？**

1. ✅ **分层解释**：从定义、原理、实现三个层次递进
2. ✅ **深入原理**：提到了 `[[Environment]]` 内部属性
3. ✅ **联系实践**：结合 React Hooks 的具体实现
4. ✅ **给出方案**：说明了常见陷阱和解决办法

---

### 问题2："React Hooks 为什么必须在函数组件顶层调用？"

**普通回答（❌ 不出彩）：**

"因为 React 规定的，不能在条件语句或循环中调用 Hook。"

**出彩回答（✅ 推荐）：**

> **这是由 Hooks 的底层实现决定的：**
>
> 1. **数据结构**：React 使用单向链表存储 Hook 状态，每个 Hook 节点通过 `next` 指针连接
>
> 2. **识别机制**：React 依赖 Hook 的**调用顺序**来识别每个 Hook，而不是通过名称或 key
>
> 3. **匹配逻辑**：每次渲染时，React 按顺序遍历链表，将 Hook 调用和链表节点一一对应
>
> **举例说明问题：**
>
> ```javascript
> function Component({ condition }) {
>   // 首次渲染：condition = true
>   if (condition) {
>     const [state1] = useState('A'); // Hook 1
>   }
>   const [state2] = useState('B');   // Hook 2
>
>   // 第二次渲染：condition = false
>   // useState('B') 现在成了 Hook 1
>   // 会读取到 'A' 的状态！
> }
> ```
>
> **为什么不用 key 识别？**
>
> - 保持 API 简洁：不需要开发者手动传 key
> - 性能考虑：顺序遍历比查找 key 更快
> - 链表结构：适合频繁的增删操作（开发模式下）
>
> **实际影响：**
>
> - ✅ 必须在顶层调用，保证顺序一致
> - ✅ 必须在函数组件或自定义 Hook 中调用
> - ✅ ESLint 插件会自动检查这些规则

**为什么这个回答出彩？**

1. ✅ **从实现出发**：说明了链表结构和顺序识别机制
2. ✅ **举例对比**：用具体代码展示了问题
3. ✅ **深度思考**：解释了"为什么不用其他方案"
4. ✅ **联系工具**：提到了 ESLint 等实践工具

---

## 九、【化骨绵掌】

### 卡片1：什么是闭包 🎯

**一句话：** 闭包是函数记住并访问其词法作用域的能力，即使函数在其定义的作用域之外执行。

**举例：**

```javascript
function outer() {
  const secret = 'password123';
  return function inner() {
    console.log(secret); // 能访问 outer 的变量
  };
}

const getSecret = outer();
getSecret(); // 'password123'
```

**应用：** React 函数组件每次渲染都是新的函数执行，通过闭包访问 Fiber 节点上的状态。

---

### 卡片2：词法作用域 📐

**一句话：** 函数的作用域在写代码时就确定了，而不是在运行时。

**举例：**

```javascript
const x = 'global';

function foo() {
  console.log(x); // 查找定义时的作用域
}

function bar() {
  const x = 'local';
  foo(); // 输出 'global'，不是 'local'
}

bar();
```

**应用：** useEffect 中的闭包捕获的是组件定义时的 props/state，而非执行时的值。

---

### 卡片3：作用域链 🔗

**一句话：** JavaScript 引擎查找变量时，从当前作用域一层层向外查找，直到全局作用域。

**举例：**

```javascript
const a = 1;
function level1() {
  const b = 2;
  function level2() {
    const c = 3;
    console.log(a, b, c); // 1, 2, 3
    // 查找链：level2 -> level1 -> global
  }
  level2();
}
level1();
```

**应用：** Hook 内部函数可以访问组件作用域的所有变量（props、state、其他 Hook）。

---

### 卡片4：闭包与内存 💾

**一句话：** 闭包会阻止被引用的变量被垃圾回收，实现状态持久化。

**举例：**

```javascript
function createArray() {
  const bigArray = new Array(1000000);
  return function() {
    return bigArray.length; // bigArray 不会被回收
  };
}
const fn = createArray(); // bigArray 常驻内存
```

**应用：** useState 的状态存储在 Fiber 节点上，通过 dispatch 闭包保持引用，在组件重渲染间保持状态。

---

### 卡片5：经典闭包模式 🔧

**一句话：** 函数返回函数，内部函数访问外部函数的变量。

**举例：**

```javascript
function counter(start) {
  let count = start;
  return {
    inc: () => ++count,
    dec: () => --count,
    get: () => count
  };
}
const c = counter(10);
c.inc(); // 11
```

**应用：** React 的自定义 Hook 返回状态和操作函数，形成闭包。

---

### 卡片6：循环中的闭包 🔄

**一句话：** 使用 `var` 时，循环中的闭包都引用同一个变量；使用 `let` 时，每次循环创建新变量。

**举例：**

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
  // 输出 0, 1, 2（每次循环创建新的 i）
}

for (var j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 0);
  // 输出 3, 3, 3（共享同一个 j）
}
```

**应用：** 在 React 中渲染列表时，事件处理器应该使用参数或 `let` 来避免闭包陷阱。

---

### 卡片7：React useState 原理 ⚛️

**一句话：** useState 通过闭包将 dispatch 函数绑定到特定的 Fiber 节点和 Hook 链表位置。

**举例：**

```javascript
// React 内部简化实现
function useState(initial) {
  const hook = getCurrentHook(); // 从链表获取 Hook
  if (!hook.state) hook.state = initial;

  const setState = (newState) => {
    hook.state = newState; // 闭包访问 hook
    scheduleRerender();
  };

  return [hook.state, setState];
}
```

**应用：** 多次调用 useState 时，每个 setState 都通过闭包知道自己对应哪个状态。

---

### 卡片8：Hook 闭包陷阱 ⚠️

**一句话：** useEffect 中的闭包如果依赖数组为空，会捕获初始值，形成"过时闭包"。

**举例：**

```javascript
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count); // 永远是 0
      setCount(count + 1); // ❌ 一直设置为 1
    }, 1000);
    return () => clearInterval(timer);
  }, []); // 空依赖 = 捕获初始值

  // 解决方案：使用函数式更新
  // setCount(c => c + 1); ✅
}
```

**应用：** 使用 useRef 或函数式更新来避免过时闭包。

---

### 卡片9：性能优化 ⚡

**一句话：** 使用 useCallback 和 useMemo 来记忆化函数和值，避免子组件不必要的重渲染。

**举例：**

```javascript
function Parent() {
  const [count, setCount] = useState(0);

  // 每次渲染都创建新函数（可能导致子组件重渲染）
  const handleClick = () => setCount(c => c + 1);

  // 使用 useCallback 记忆化
  const memoizedHandler = useCallback(() => {
    setCount(c => c + 1);
  }, []); // 依赖为空，函数永不变

  return <Child onClick={memoizedHandler} />;
}
```

**应用：** 传递给 React.memo 组件的函数 props 应该用 useCallback 包裹。

---

### 卡片10：实战应用总结 🎓

**一句话：** 掌握闭包是精通 React Hooks、避免常见陷阱、优化性能的基础。

**关键技巧：**
- ✅ 理解 Hook 调用顺序和链表结构
- ✅ 正确设置 useEffect 依赖数组
- ✅ 使用函数式更新避免过时闭包
- ✅ 及时清理副作用（事件监听、定时器）
- ✅ 用 useCallback/useMemo 优化性能
- ✅ 使用 ESLint 插件自动检查

**应用：** 从状态管理（useState）到副作用（useEffect），再到性能优化（useCallback/useMemo），闭包无处不在。

---

## 十、【一句话总结】

**闭包是函数和其词法环境的组合，通过作用域链保持对外部变量的引用，在 React 中是 Hooks 状态管理、事件处理和副作用保存的核心机制，正确理解闭包能避免过时闭包、内存泄漏等常见陷阱。**

---

## ✅ 学习检查清单

### 基础理解
- [ ] 能用自己的话解释什么是闭包
- [ ] 理解词法作用域和作用域链
- [ ] 知道闭包如何影响垃圾回收
- [ ] 能写出基本的闭包代码

### React 应用
- [ ] 理解 useState 的闭包实现原理
- [ ] 知道为什么 Hook 必须在顶层调用
- [ ] 能识别和解决过时闭包问题
- [ ] 会使用函数式更新
- [ ] 正确设置 useEffect 依赖数组

### 常见陷阱
- [ ] 知道循环中 var 和 let 的区别
- [ ] 能避免事件监听器导致的内存泄漏
- [ ] 理解闭包与内存泄漏的关系
- [ ] 会使用 useCallback/useMemo 优化

### 进阶知识
- [ ] 理解 Hook 链表的数据结构
- [ ] 知道 dispatch 函数的闭包绑定
- [ ] 了解 Fiber 节点的 memoizedState
- [ ] 能读懂 React Hooks 的源码实现

---

## 📚 下一步学习

掌握闭包后，建议学习：

1. **事件循环与微任务** - 理解异步操作和 Effect 执行时机
2. **Fiber 架构** - 深入 React 内部的数据结构
3. **Hooks 实现原理** - 从源码层面理解 useState、useEffect
4. **性能优化** - React.memo、useCallback、useMemo 的最佳实践

---

## 🔗 参考资源

- [MDN - 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
- [React 官方文档 - Hooks 规则](https://react.dev/reference/rules/rules-of-hooks)
- [React 源码 - ReactFiberHooks.js](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js)
- [Dan Abramov - useEffect 完全指南](https://overreacted.io/a-complete-guide-to-useeffect/)

---

**🎯 记住：闭包不是魔法，而是 JavaScript 词法作用域的自然结果！**
