# 优先级定义

## 一、【30字核心】

**Scheduler优先级定义了5个等级（立即、用户阻塞、正常、低、空闲），每个等级对应不同的超时时间，确保高优先级任务优先执行。**

---

## 二、【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 优先级定义的第一性原理 🎯

#### 1. 最基础的定义

**优先级 = 数字标识 + 超时时间**

仅此而已！没有更基础的了。

优先级本质上就是给不同的任务打上不同的标签，每个标签对应一个数字和一个超时时间。就这么简单。

```javascript
// 最基础的优先级定义
const ImmediatePriority = 1;      // 立即执行，超时 -1ms
const UserBlockingPriority = 2;   // 用户阻塞，超时 250ms
const NormalPriority = 3;         // 正常，超时 5000ms
const LowPriority = 4;            // 低，超时 10000ms
const IdlePriority = 5;           // 空闲，超时 1073741823ms（接近无限大）
```

#### 2. 为什么需要优先级？

**核心问题：多个任务同时存在时，应该先执行哪个？**

在日常生活中，我们总是面临多个任务需要处理的情况：
- 老板让你写报告（紧急）
- 同事让你帮忙改bug（重要）
- 定期的代码审查（常规）
- 整理文档（不急）
- 学习新技术（空闲时间）

如果没有优先级，你可能会：
- ❌ 按照任务到达的顺序执行（先来先服务）→ 可能导致紧急任务被延误
- ❌ 随机选择执行（乱序执行）→ 可能导致重要任务永远得不到执行
- ❌ 平均分配时间给所有任务→ 可能导致所有任务都无法及时完成

**React的问题也一样：**
- 用户点击按钮（需要立即响应）
- 输入框打字（需要快速反馈）
- 网络请求返回数据（正常处理）
- 数据分析统计（低优先级）
- 日志上报（空闲时处理）

没有优先级，React无法决定先处理哪个任务，可能导致用户界面卡顿。

#### 3. 优先级的三层价值

##### 价值1：确保关键任务优先执行

通过优先级，React可以确保用户交互任务（如点击、输入）优先于后台任务（如数据统计）。

```javascript
// 没有优先级：按顺序执行
const tasks = [
  { name: '数据统计', time: 100 },
  { name: '用户点击', time: 10 },    // 用户需要等110ms才能看到响应
  { name: '网络请求', time: 50 }
];

// 有优先级：按优先级执行
const tasksWithPriority = [
  { name: '用户点击', priority: 2, time: 10 },    // 立即执行
  { name: '网络请求', priority: 3, time: 50 },    // 其次
  { name: '数据统计', priority: 4, time: 100 }    // 最后
];
```

##### 价值2：防止任务饥饿

超时时间确保即使是低优先级任务，在等待一定时间后也会被提升优先级执行。

```javascript
// 任务的过期时间 = 创建时间 + 超时时间
const task = {
  priority: LowPriority,        // 低优先级
  timeout: 10000,               // 超时 10秒
  createdAt: 1000,              // 创建时间
  expirationTime: 1000 + 10000  // 过期时间 = 11000
};

// 当 currentTime >= expirationTime 时，任务变为过期任务
// 过期任务会被提升为最高优先级立即执行
if (currentTime >= task.expirationTime) {
  // 任务已过期，必须立即执行！
  executeTask(task);
}
```

**为什么这很重要？**

假设一个低优先级任务一直被高优先级任务插队，如果没有超时机制，这个低优先级任务可能永远得不到执行（饥饿问题）。

超时机制确保：即使你的优先级很低，等待足够久后，你也一定会被执行。

##### 价值3：时间切片配合

优先级配合时间切片机制，实现可中断的任务调度。

```javascript
// 工作循环：每次执行一个任务，检查是否超时
function workLoop() {
  while (currentTask !== null && !shouldYield()) {
    // 执行当前任务
    currentTask = performWork(currentTask);
  }

  // 如果时间片用完，让出控制权
  if (shouldYield()) {
    scheduleCallback(continueLater);
  }
}

function shouldYield() {
  // 检查当前时间片是否用完
  return getCurrentTime() >= deadline;
}
```

**关键点：**
- 高优先级任务分配更少的时间片（快速完成）
- 低优先级任务分配更多的时间片（慢慢处理）
- 时间片用完后，重新调度下一个最高优先级的任务

#### 4. 从第一性原理推导 React 实现

**推理链：**
```
1. 前提：多个任务需要执行，主线程时间有限
   ↓
2. 推导：需要一个机制决定先执行哪个任务
   ↓
3. 推导：引入优先级概念，给每个任务打标签
   ↓
4. 推导：优先级高的任务先执行，但如何量化"高"和"低"？
   ↓
5. 推导：用数字表示优先级等级（1=最高，5=最低）
   ↓
6. 推导：如何防止低优先级任务永远得不到执行？
   ↓
7. 推导：引入超时时间，任务等待超时后提升为最高优先级
   ↓
8. 推导：超时时间应该根据优先级等级不同而不同
   ↓
9. 推导：定义5个优先级等级，每个等级对应不同的超时时间
   ↓
10. 最终应用：React Scheduler的5级优先级系统
    - ImmediatePriority: -1ms（立即执行）
    - UserBlockingPriority: 250ms（用户感知）
    - NormalPriority: 5000ms（常规任务）
    - LowPriority: 10000ms（后台任务）
    - IdlePriority: 无限大（空闲时执行）
```

#### 5. 一句话总结第一性原理

**优先级是给任务分配执行顺序的标签，通过数字等级和超时时间保证高优先级任务优先执行，同时防止低优先级任务饥饿。**

---

## 三、【3个核心概念】

### 核心概念1：优先级等级 🔢

**React Scheduler 定义了5个优先级等级，从最高到最低依次为：立即、用户阻塞、正常、低、空闲。**

```javascript
// React Scheduler 的5个优先级常量
const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;
```

**详细解释：**

1. **ImmediatePriority（立即优先级）**
   - 数值：1
   - 超时时间：-1ms（立即过期）
   - 使用场景：同步任务、关键错误处理
   - 示例：React 的 `flushSync()`

2. **UserBlockingPriority（用户阻塞优先级）**
   - 数值：2
   - 超时时间：250ms
   - 使用场景：用户交互（点击、输入、拖拽）
   - 示例：点击按钮触发的状态更新

3. **NormalPriority（正常优先级）**
   - 数值：3
   - 超时时间：5000ms（5秒）
   - 使用场景：网络请求、常规更新
   - 示例：数据加载完成后的渲染

4. **LowPriority（低优先级）**
   - 数值：4
   - 超时时间：10000ms（10秒）
   - 使用场景：不紧急的后台任务
   - 示例：数据预取、分析统计

5. **IdlePriority（空闲优先级）**
   - 数值：5
   - 超时时间：1073741823ms（约12.4天，接近无限）
   - 使用场景：完全不紧急的任务
   - 示例：日志上报、性能监控

**在 React 源码/开发中的应用：**

```javascript
// React 中不同更新的优先级
function App() {
  const [count, setCount] = useState(0);

  // UserBlockingPriority: 用户点击
  const handleClick = () => {
    setCount(c => c + 1);  // 高优先级，需要立即响应
  };

  // NormalPriority: 数据加载
  useEffect(() => {
    fetch('/api/data').then(data => {
      setData(data);  // 正常优先级
    });
  }, []);

  // LowPriority: 后台任务
  useEffect(() => {
    startTransition(() => {
      // 低优先级更新，可以被打断
      processLargeData();
    });
  }, []);
}
```

### 核心概念2：超时时间（Timeout） ⏰

**每个优先级对应一个超时时间，任务创建后如果在超时时间内未执行，将被标记为过期任务并立即执行。**

```javascript
// 超时时间定义
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = 1073741823; // 最大31位有符号整数

// 根据优先级获取超时时间
function timeoutForPriorityLevel(priorityLevel) {
  switch (priorityLevel) {
    case ImmediatePriority:
      return IMMEDIATE_PRIORITY_TIMEOUT;
    case UserBlockingPriority:
      return USER_BLOCKING_PRIORITY_TIMEOUT;
    case NormalPriority:
      return NORMAL_PRIORITY_TIMEOUT;
    case LowPriority:
      return LOW_PRIORITY_TIMEOUT;
    case IdlePriority:
      return IDLE_PRIORITY_TIMEOUT;
    default:
      return NORMAL_PRIORITY_TIMEOUT;
  }
}
```

**详细解释：**

任务的过期时间计算公式：
```javascript
expirationTime = currentTime + timeout
```

示例：
```javascript
// 当前时间：1000ms
const currentTime = 1000;

// 创建一个正常优先级任务
const normalTask = {
  priority: NormalPriority,
  timeout: 5000,
  expirationTime: 1000 + 5000  // = 6000ms
};

// 在 6000ms 之前执行都是正常的
// 如果超过 6000ms 还没执行，任务就过期了
if (getCurrentTime() >= normalTask.expirationTime) {
  // 任务过期！必须立即执行
  executeImmediately(normalTask);
}
```

**为什么需要超时时间？**

1. **防止饥饿**：确保低优先级任务最终会被执行
2. **时间保证**：给开发者一个预期（用户交互在250ms内响应）
3. **优先级提升**：过期任务自动提升为最高优先级

**在 React 源码/开发中的应用：**

```javascript
// packages/scheduler/src/forks/Scheduler.js

function unstable_scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();

  // 计算任务的开始时间
  const startTime = currentTime;

  // 根据优先级获取超时时间
  const timeout = timeoutForPriorityLevel(priorityLevel);

  // 计算过期时间
  const expirationTime = startTime + timeout;

  // 创建新任务
  const newTask = {
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: expirationTime  // 用于最小堆排序
  };

  // 将任务加入队列
  push(taskQueue, newTask);

  // 开始调度
  requestHostCallback(flushWork);
}
```

### 核心概念3：任务过期（Expiration） 🚨

**任务过期是指任务的等待时间超过了它的超时时间，过期任务会被立即执行，不可中断。**

```javascript
// 检查任务是否过期
function isTaskExpired(task) {
  const currentTime = getCurrentTime();
  return currentTime >= task.expirationTime;
}

// 执行工作循环
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);  // 获取最小堆顶部任务

  while (currentTask !== null) {
    // 关键判断：任务未过期 且 时间片用完
    if (currentTask.expirationTime > currentTime &&
        (!hasTimeRemaining || shouldYield())) {
      // 任务未过期，但时间片用完了，可以中断
      break;
    }

    // 执行任务（过期任务必须执行，不会被中断）
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      callback();
    }

    // 移除已执行的任务
    pop(taskQueue);
    currentTask = peek(taskQueue);
    currentTime = getCurrentTime();
  }
}
```

**详细解释：**

过期任务的特殊性：
1. **不可中断**：即使时间片用完，过期任务也必须执行完
2. **最高优先级**：过期任务会被提升到最高优先级
3. **同步执行**：过期任务通常会阻塞其他任务

**过期判断逻辑：**

```javascript
// 案例1：未过期的任务可以被中断
const task1 = {
  expirationTime: 6000,  // 过期时间 6000ms
};
const currentTime = 5000;  // 当前时间 5000ms

if (task1.expirationTime > currentTime) {
  // 5000 < 6000，任务未过期
  if (shouldYield()) {
    // 如果时间片用完，可以中断
    break;
  }
}

// 案例2：过期的任务必须执行
const task2 = {
  expirationTime: 5000,  // 过期时间 5000ms
};
const currentTime = 6000;  // 当前时间 6000ms

if (task2.expirationTime <= currentTime) {
  // 6000 >= 5000，任务已过期
  // 必须执行，不管时间片是否用完
  executeTask(task2);
}
```

**在 React 源码/开发中的应用：**

```javascript
// React 中的过期任务场景

// 场景1：低优先级任务等待太久
function Component() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // 低优先级任务：预加载数据
    startTransition(() => {
      fetchData().then(result => {
        setData(result);  // 低优先级更新
      });
    });

    // 如果 10秒 后数据还没加载完，任务会过期
    // 过期后会被提升为最高优先级，立即执行
  }, []);
}

// 场景2：用户交互任务
function Button() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // 用户阻塞优先级：250ms 超时
    setCount(c => c + 1);

    // 如果 250ms 内没有执行，任务过期
    // 用户会感觉界面卡顿
  };
}
```

**过期任务的可视化理解：**

```
时间线：
0ms -------- 250ms -------- 5000ms -------- 10000ms ---------->
     |          |              |               |
     创建任务    UserBlocking   Normal          Low
     |          过期           过期            过期
     |          ↓              ↓               ↓
     |          必须执行        必须执行         必须执行
```

---

## 四、【最小可用】

掌握以下内容，就能理解 React Scheduler 优先级系统的核心：

### 4.1 记住5个优先级等级

**最关键的5个优先级和它们的超时时间：**

| 优先级等级 | 数值 | 超时时间 | 典型场景 |
|-----------|------|---------|---------|
| Immediate | 1 | -1ms | 同步任务、flushSync |
| UserBlocking | 2 | 250ms | 点击、输入 |
| Normal | 3 | 5000ms | 数据加载 |
| Low | 4 | 10000ms | 后台任务 |
| Idle | 5 | 无限大 | 日志上报 |

```javascript
// 只需记住这5行
const ImmediatePriority = 1;       // -1ms
const UserBlockingPriority = 2;    // 250ms
const NormalPriority = 3;          // 5000ms
const LowPriority = 4;             // 10000ms
const IdlePriority = 5;            // 无限大
```

### 4.2 理解过期时间计算

**核心公式：**
```javascript
expirationTime = currentTime + timeout
```

示例：
```javascript
// 当前时间 1000ms，创建一个用户阻塞优先级任务
const task = {
  priority: UserBlockingPriority,
  expirationTime: 1000 + 250  // = 1250ms
};

// 在 1250ms 之前执行都正常
// 超过 1250ms 就过期了，必须立即执行
```

### 4.3 掌握任务过期判断

**核心判断：**
```javascript
if (currentTime >= task.expirationTime) {
  // 任务过期，必须立即执行
  executeImmediately(task);
} else if (shouldYield()) {
  // 任务未过期，且时间片用完，可以中断
  pauseAndScheduleLater(task);
} else {
  // 任务未过期，时间片够用，继续执行
  continueExecution(task);
}
```

### 4.4 知道优先级的实际应用

**React 中的优先级映射：**

```javascript
// 用户交互 → UserBlockingPriority
onClick={() => setCount(c => c + 1)}

// 数据加载 → NormalPriority
useEffect(() => {
  fetch('/api').then(data => setData(data));
}, []);

// 低优先级更新 → LowPriority
startTransition(() => {
  setFilteredList(expensiveFilter(list));
});

// 同步更新 → ImmediatePriority
flushSync(() => {
  setUrgentState(value);
});
```

### 4.5 理解为什么需要优先级

**核心原因：**

1. **保证用户体验**：用户交互（250ms）必须快于数据加载（5000ms）
2. **防止饥饿**：低优先级任务最终会过期并执行
3. **可中断渲染**：未过期的任务可以被更高优先级任务打断

**这些知识足以：**
- 理解 React Scheduler 如何调度不同优先级的任务
- 知道为什么用户交互响应快，而低优先级任务可以被延迟
- 明白过期任务为什么必须立即执行
- 为后续学习时间切片、最小堆任务队列打下基础

---

## 五、【1个类比】

用生活场景类比帮助理解 React Scheduler 的优先级系统：

### 类比1：医院分诊台 = Scheduler优先级系统 🏥

**React 概念**：Scheduler 需要处理多个不同优先级的任务

**生活场景**：医院分诊台需要处理不同紧急程度的病人

**相似性解释：**

医院分诊台会根据病人的病情紧急程度分配不同的优先级：

```javascript
// 医院分诊系统
const 急诊 = 1;        // 立即处理（生命危险）
const 普通门诊 = 2;     // 快速处理（影响生活）
const 体检 = 3;        // 正常处理（预防保健）
const 健康咨询 = 4;     // 稍后处理（不紧急）
const 义诊 = 5;        // 空闲时处理（完全不急）

// React Scheduler 优先级
const ImmediatePriority = 1;       // 立即执行
const UserBlockingPriority = 2;    // 快速执行
const NormalPriority = 3;          // 正常执行
const LowPriority = 4;             // 稍后执行
const IdlePriority = 5;            // 空闲时执行
```

**举例：**

周六上午的医院，同时来了5个病人：

1. **病人A**：突发心脏病（急诊） → `ImmediatePriority`
   - 立即安排手术室，不管正在做什么
   - 超时时间：-1ms（立即处理）

2. **病人B**：骨折疼痛（普通门诊） → `UserBlockingPriority`
   - 优先处理，等待时间不超过15分钟
   - 超时时间：250ms

3. **病人C**：感冒拿药（普通门诊） → `NormalPriority`
   - 正常排队，等待时间约1小时
   - 超时时间：5000ms

4. **病人D**：健康咨询（咨询台） → `LowPriority`
   - 可以稍后处理，等待2小时内
   - 超时时间：10000ms

5. **病人E**：免费义诊（义诊区） → `IdlePriority`
   - 医生有空时再处理
   - 超时时间：无限大

**过期机制的类比：**

```javascript
// 病人B（骨折）等待了20分钟还没被处理
const 病人B = {
  病情: '骨折',
  优先级: 普通门诊,
  超时时间: 15分钟,
  等待时间: 20分钟  // 已经超时！
};

// 虽然病人B不是急诊，但等待超时了
// 医院会提升优先级，立即安排医生处理
if (病人B.等待时间 > 病人B.超时时间) {
  提升为急诊级别();
  立即安排医生();
}
```

在 React 中也一样：

```javascript
// 用户点击按钮（用户阻塞优先级，250ms超时）
const userClickTask = {
  priority: UserBlockingPriority,
  timeout: 250,
  createdAt: 1000,
  expirationTime: 1250
};

// 如果 250ms 后还没执行
if (currentTime >= 1250) {
  // 任务过期，提升为最高优先级立即执行
  executeImmediately(userClickTask);
}
```

---

### 类比2：快递优先级 = 任务优先级 📦

**React 概念**：不同优先级的任务有不同的超时时间

**生活场景**：不同类型的快递有不同的送达时间承诺

**相似性解释：**

```javascript
// 快递优先级系统
const 特急件 = {
  优先级: 1,
  承诺时间: '立即送达（4小时内）',
  对应: ImmediatePriority
};

const 加急件 = {
  优先级: 2,
  承诺时间: '当日达（24小时内）',
  对应: UserBlockingPriority
};

const 普通件 = {
  优先级: 3,
  承诺时间: '3天内送达',
  对应: NormalPriority
};

const 慢递 = {
  优先级: 4,
  承诺时间: '7天内送达',
  对应: LowPriority
};

const 平邮 = {
  优先级: 5,
  承诺时间: '有车就送（不保证时间）',
  对应: IdlePriority
};
```

**举例：**

快递站点同时收到5个包裹：

```javascript
// 包裹调度系统（类似 React Scheduler）
const packages = [
  { type: '特急件', timeout: 4小时, 内容: '救命药品' },
  { type: '加急件', timeout: 24小时, 内容: '生日礼物' },
  { type: '普通件', timeout: 3天, 内容: '日用品' },
  { type: '慢递', timeout: 7天, 内容: '书籍' },
  { type: '平邮', timeout: 无限, 内容: '宣传资料' }
];

// 快递员优先送特急件，然后加急件...
// 如果慢递等了7天还没送，会被提升优先级
packages.forEach(pkg => {
  if (当前时间 - pkg.收件时间 > pkg.timeout) {
    // 包裹超时，必须立即派送
    pkg.优先级 = 特急件;
    立即派送(pkg);
  }
});
```

---

### 类比3：餐厅点单系统 = 优先级队列 🍽️

**React 概念**：不同优先级的任务在队列中的位置不同

**生活场景**：餐厅根据用餐方式（堂食、外卖、预约）安排不同的优先级

**相似性解释：**

```javascript
// 餐厅订单系统
const 订单类型 = {
  现场等待: {  // 客人在餐厅等，必须快速出餐
    优先级: UserBlockingPriority,
    超时: 15分钟,
    原因: '客人会催促，影响体验'
  },
  外卖订单: {  // 骑手在等，需要及时出餐
    优先级: NormalPriority,
    超时: 30分钟,
    原因: '骑手可以等一会儿'
  },
  预约订单: {  // 客人预约的，可以提前准备
    优先级: LowPriority,
    超时: 2小时,
    原因: '有充足的准备时间'
  },
  团购券: {    // 团购用户，空闲时处理
    优先级: IdlePriority,
    超时: 无限,
    原因: '价格低，不着急'
  }
};
```

**举例：**

晚餐高峰期，厨房同时收到4个订单：

```javascript
// 厨房订单队列
const kitchen = {
  订单1: { 类型: '现场等待', 下单时间: '18:00', 超时: 15分钟 },
  订单2: { 类型: '外卖订单', 下单时间: '18:05', 超时: 30分钟 },
  订单3: { 类型: '预约订单', 下单时间: '17:00', 超时: 2小时 },
  订单4: { 类型: '团购券', 下单时间: '17:30', 超时: 无限 }
};

// 厨师的优先级判断
function 决定做哪个订单() {
  // 1. 先检查是否有超时的订单（类似过期任务）
  const 超时订单 = kitchen.filter(订单 => {
    return (当前时间 - 订单.下单时间) > 订单.超时;
  });

  if (超时订单.length > 0) {
    // 有超时订单，立即处理
    return 超时订单[0];
  }

  // 2. 按优先级处理：现场 > 外卖 > 预约 > 团购
  return kitchen.sort((a, b) => a.优先级 - b.优先级)[0];
}
```

在 React 中：

```javascript
// React 组件更新优先级
function Restaurant() {
  const [现场订单, set现场订单] = useState([]);
  const [外卖订单, set外卖订单] = useState([]);
  const [预约订单, set预约订单] = useState([]);

  // 现场客人点单 - UserBlockingPriority
  const handleDineIn = (order) => {
    set现场订单(orders => [...orders, order]);
    // 立即更新UI，客人在等
  };

  // 外卖订单 - NormalPriority
  const handleTakeout = (order) => {
    set外卖订单(orders => [...orders, order]);
    // 正常更新
  };

  // 预约订单 - LowPriority
  const handleReservation = (order) => {
    startTransition(() => {
      set预约订单(orders => [...orders, order]);
      // 低优先级更新，可以被打断
    });
  };
}
```

---

### 类比4：高速公路车道 = 优先级通道 🚗

**React 概念**：优先级决定了任务的执行速度

**生活场景**：高速公路的不同车道有不同的速度限制

**相似性解释：**

```javascript
// 高速公路车道系统
const 高速公路 = {
  应急车道: {  // 救护车、消防车专用
    优先级: ImmediatePriority,
    限速: '不限速',
    规则: '其他车辆必须让行'
  },
  快车道: {    // 小型车，速度快
    优先级: UserBlockingPriority,
    限速: '100-120km/h',
    规则: '快速通行，不得占用'
  },
  中间车道: {  // 正常行驶
    优先级: NormalPriority,
    限速: '80-100km/h',
    规则: '正常通行'
  },
  慢车道: {    // 大货车专用
    优先级: LowPriority,
    限速: '60-80km/h',
    规则: '慢速通行'
  }
};
```

**举例：**

```javascript
// 车辆调度系统
const vehicles = [
  { type: '救护车', lane: '应急车道', priority: 1 },
  { type: '小轿车', lane: '快车道', priority: 2 },
  { type: '普通车', lane: '中间车道', priority: 3 },
  { type: '货车', lane: '慢车道', priority: 4 }
];

// 规则：救护车来了，其他车辆必须让行（类似过期任务）
if (有救护车()) {
  所有车辆靠边停车();
  救护车优先通过();
}
```

---

### 类比总结表

| React 概念 | 生活场景类比 | 核心相似点 |
|-----------|------------|-----------|
| ImmediatePriority | 医院急诊 / 特急件 / 救护车 | 立即处理，不可延误 |
| UserBlockingPriority | 普通门诊 / 加急件 / 快车道 | 快速处理，用户感知 |
| NormalPriority | 体检 / 普通件 / 中间车道 | 正常处理，不紧不慢 |
| LowPriority | 健康咨询 / 慢递 / 慢车道 | 可以延后，但会完成 |
| IdlePriority | 义诊 / 平邮 / 空闲时处理 | 有空再做，不保证时间 |
| 过期任务 | 等待超时的病人 / 超时快递 | 超时后提升优先级 |
| 任务队列 | 医院排队系统 / 餐厅订单 | 按优先级排序执行 |

---

## 六、【反直觉点】

### 误区1：优先级数字越大越重要 ❌

**为什么错？**

在 React Scheduler 中，优先级数字越小越重要：
- `ImmediatePriority = 1`（最高优先级）
- `IdlePriority = 5`（最低优先级）

这与日常生活中"第一名最好"的概念一致，但容易与某些系统混淆（如CSS的z-index，数字越大越靠前）。

**为什么人们容易这样错？**

在某些编程场景中，我们习惯用大数字表示重要性：
- CSS的 `z-index: 9999`（数字大，层级高）
- 优先级队列的权重值（数字大，优先级高）
- 进程调度的nice值（但这也是数字小优先级高）

这种混淆来自于不同系统的设计惯例不一致。

**正确理解：**

```javascript
// ❌ 错误理解
const priorities = [
  { name: 'Idle', level: 5, importance: '最重要' },     // 错！
  { name: 'Low', level: 4, importance: '第二重要' },
  { name: 'Normal', level: 3, importance: '第三重要' },
  { name: 'UserBlocking', level: 2, importance: '第四重要' },
  { name: 'Immediate', level: 1, importance: '最不重要' }  // 错！
];

// ✅ 正确理解
const priorities = [
  { name: 'Immediate', level: 1, importance: '最重要' },     // 对！
  { name: 'UserBlocking', level: 2, importance: '第二重要' },
  { name: 'Normal', level: 3, importance: '第三重要' },
  { name: 'Low', level: 4, importance: '第四重要' },
  { name: 'Idle', level: 5, importance: '最不重要' }        // 对！
];

// 记忆技巧：想象成比赛排名，第1名最好
console.log('第1名 = ImmediatePriority = 最高优先级');
console.log('第5名 = IdlePriority = 最低优先级');
```

**实际应用中的正确用法：**

```javascript
// 比较两个任务的优先级
function shouldPreempt(newTask, currentTask) {
  // 数字小的优先级高，应该抢占
  return newTask.priority < currentTask.priority;
}

// 示例
const immediateTask = { priority: 1 };  // ImmediatePriority
const normalTask = { priority: 3 };     // NormalPriority

console.log(shouldPreempt(immediateTask, normalTask));  // true
// 1 < 3，立即任务应该抢占正常任务
```

---

### 误区2：超时时间到了，任务就会自动执行 ❌

**为什么错？**

超时时间只是一个标记，表示任务应该在这个时间之前执行。超时时间到了，任务不会自动执行，而是被标记为"过期"，等待调度器在下一次检查时发现并执行。

**关键区别：**
- ❌ 错误理解：超时时间 = 定时器，时间到了自动触发
- ✅ 正确理解：超时时间 = 截止时间，过期后优先级提升

**为什么人们容易这样错？**

因为"超时"这个词让人联想到 `setTimeout`：

```javascript
// setTimeout 的行为（时间到了自动执行）
setTimeout(() => {
  console.log('时间到了，我被自动调用了！');
}, 1000);

// 但 Scheduler 的超时不是这样的！
const task = {
  expirationTime: currentTime + 1000
};
// 1000ms 后，任务不会自动执行
// 而是等待调度器检查时发现它过期了，才会执行
```

**正确理解：**

```javascript
// React Scheduler 的实际工作方式

// 1. 创建任务时计算过期时间
function scheduleTask(priority, callback) {
  const currentTime = getCurrentTime();
  const timeout = getTimeout(priority);
  const expirationTime = currentTime + timeout;

  const newTask = {
    callback,
    expirationTime,
    priority
  };

  push(taskQueue, newTask);  // 加入队列
  requestHostCallback(flushWork);  // 请求调度
}

// 2. 调度器在工作循环中检查任务是否过期
function workLoop() {
  const currentTime = getCurrentTime();
  currentTask = peek(taskQueue);

  while (currentTask !== null) {
    // 检查任务是否过期
    if (currentTask.expirationTime > currentTime && shouldYield()) {
      // 任务未过期，且时间片用完，可以中断
      break;
    }

    // 任务过期了，或者时间片还够用，继续执行
    const callback = currentTask.callback;
    callback();

    pop(taskQueue);
    currentTask = peek(taskQueue);
  }
}

// 3. 关键点：过期判断发生在 workLoop 中
// 不是在过期时间到达时自动触发
```

**可视化理解：**

```
时间线：
0ms         1000ms        2000ms        3000ms
|            |             |             |
创建任务      过期时间到了    调度器检查     任务执行
expirationTime=1000        ↓             ↓
                          （什么也不会发生） （发现过期，执行）

// 错误理解：过期时间到了就自动执行
0ms         1000ms
|            ↓
创建任务      自动执行（❌ 不会发生！）

// 正确理解：调度器检查时发现过期，才执行
0ms         1000ms        2000ms
|            |             ↓
创建任务      过期时间      调度器检查时发现过期，执行（✅）
```

**实际案例：**

```javascript
// 创建一个正常优先级任务
const task = {
  priority: NormalPriority,
  expirationTime: 1000 + 5000,  // 5秒后过期
  callback: () => console.log('任务执行了')
};

// 5秒后...
// ❌ 错误预期：任务自动执行，打印 "任务执行了"
// ✅ 实际情况：什么也不会发生，直到调度器下次检查

// 调度器可能在 6秒 时才检查
// 此时发现任务过期了，才会执行
```

---

### 误区3：低优先级任务永远得不到执行 ❌

**为什么错？**

虽然高优先级任务会插队，但低优先级任务有超时机制保护，等待超时后会被提升为最高优先级，保证最终一定会执行。

**为什么人们容易这样错？**

在日常经验中，"优先级低"往往意味着"可能被忽略"：
- 工作中，紧急任务总是打断非紧急任务
- 医院急诊会让普通门诊等很久
- 快递加急件会让普通件延迟

这导致我们担心：如果一直有高优先级任务，低优先级任务是不是永远排不上？

**正确理解：**

```javascript
// 低优先级任务的生命周期

// 1. 创建时：优先级低，超时时间长
const lowPriorityTask = {
  priority: LowPriority,       // 优先级 4
  timeout: 10000,              // 超时 10秒
  createdAt: 1000,             // 创建时间
  expirationTime: 1000 + 10000 // 过期时间 11000
};

// 2. 前 10秒：可能被高优先级任务插队
// 时间 2000ms：高优先级任务来了，插队执行
// 时间 3000ms：又一个高优先级任务，继续插队
// 时间 5000ms：再一个高优先级任务，又插队
// ... 低优先级任务一直在等待

// 3. 第 11秒：任务过期了！
const currentTime = 11000;
if (currentTime >= lowPriorityTask.expirationTime) {
  // 任务过期，优先级提升为最高
  lowPriorityTask.priority = ImmediatePriority;  // 1

  // 现在即使有新的高优先级任务来了，也得等这个过期任务执行完
  executeImmediately(lowPriorityTask);
}
```

**可视化饥饿问题的解决：**

```
没有超时机制（会饥饿）：
时间轴: 0s --- 2s --- 4s --- 6s --- 8s --- 10s --- 12s --->
任务:   Low   High   High   High   High   High    High ...
结果:   ✅    ✅     ✅     ✅     ✅     ✅      ✅
        等待  插队   插队   插队   插队   插队    插队
        ❌ Low 任务永远得不到执行（饥饿）

有超时机制（不会饥饿）：
时间轴: 0s --- 2s --- 4s --- 6s --- 8s --- 10s --- 12s --->
任务:   Low   High   High   High   High   High    过期！
结果:   创建  插队   插队   插队   插队   插队    ✅ 强制执行
过期:   no    no     no     no     no     no      yes!
        ✅ 10秒后 Low 任务过期，被强制执行
```

**实际代码示例：**

```javascript
// React Scheduler 的防饥饿机制

function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);

  while (currentTask !== null) {
    // 关键判断：任务过期了吗？
    const isExpired = currentTask.expirationTime <= currentTime;

    if (!isExpired && (!hasTimeRemaining || shouldYield())) {
      // 任务未过期，且没有时间了，可以中断
      // 让高优先级任务插队
      break;
    }

    // 任务过期了，必须执行！不管有没有更高优先级任务
    // 或者任务未过期但时间够用，继续执行
    const callback = currentTask.callback;
    callback();

    pop(taskQueue);
    currentTask = peek(taskQueue);
    currentTime = getCurrentTime();
  }
}
```

**真实场景举例：**

```javascript
// 场景：用户在编辑长文档
function Editor() {
  const [content, setContent] = useState('');
  const [wordCount, setWordCount] = useState(0);

  const handleChange = (e) => {
    // 高优先级：立即更新输入内容
    setContent(e.target.value);

    // 低优先级：计算字数统计（慢）
    startTransition(() => {
      const count = expensiveWordCount(e.target.value);
      setWordCount(count);
    });
  };

  // 用户快速打字时：
  // - 输入内容立即更新（高优先级）
  // - 字数统计被延迟（低优先级）

  // 但是！即使用户一直打字（一直有高优先级任务）
  // 字数统计任务最多等待 10秒 就会被强制执行
  // 保证用户最终能看到字数统计更新
}
```

**总结：**

低优先级任务的保护机制：
1. **有超时时间**：LowPriority = 10秒
2. **过期后提升**：过期后变成 ImmediatePriority
3. **强制执行**：过期任务不可中断，必须执行
4. **防止饥饿**：保证即使一直有高优先级任务，低优先级任务最终也会执行

---

## 七、【实战代码】

### 基础实现（简化版）

下面是一个完整可运行的优先级系统简化实现：

```javascript
// ===== 1. 定义5个优先级常量 =====
console.log("=== 1. 优先级定义 ===");

const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;

// 优先级名称映射
const priorityNames = {
  1: 'Immediate（立即）',
  2: 'UserBlocking（用户阻塞）',
  3: 'Normal（正常）',
  4: 'Low（低）',
  5: 'Idle（空闲）'
};

console.log('优先级等级：');
console.log(`  ${ImmediatePriority} - ${priorityNames[1]}`);
console.log(`  ${UserBlockingPriority} - ${priorityNames[2]}`);
console.log(`  ${NormalPriority} - ${priorityNames[3]}`);
console.log(`  ${LowPriority} - ${priorityNames[4]}`);
console.log(`  ${IdlePriority} - ${priorityNames[5]}`);

// ===== 2. 定义超时时间 =====
console.log("\n=== 2. 超时时间定义 ===");

const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = 1073741823; // 最大31位有符号整数

function timeoutForPriorityLevel(priorityLevel) {
  switch (priorityLevel) {
    case ImmediatePriority:
      return IMMEDIATE_PRIORITY_TIMEOUT;
    case UserBlockingPriority:
      return USER_BLOCKING_PRIORITY_TIMEOUT;
    case NormalPriority:
      return NORMAL_PRIORITY_TIMEOUT;
    case LowPriority:
      return LOW_PRIORITY_TIMEOUT;
    case IdlePriority:
      return IDLE_PRIORITY_TIMEOUT;
    default:
      return NORMAL_PRIORITY_TIMEOUT;
  }
}

console.log('优先级超时时间：');
console.log(`  Immediate: ${IMMEDIATE_PRIORITY_TIMEOUT}ms`);
console.log(`  UserBlocking: ${USER_BLOCKING_PRIORITY_TIMEOUT}ms`);
console.log(`  Normal: ${NORMAL_PRIORITY_TIMEOUT}ms`);
console.log(`  Low: ${LOW_PRIORITY_TIMEOUT}ms`);
console.log(`  Idle: ${IDLE_PRIORITY_TIMEOUT}ms`);

// ===== 3. 创建任务 =====
console.log("\n=== 3. 创建任务 ===");

let taskIdCounter = 1;
let currentTime = 1000; // 模拟当前时间 1000ms

function getCurrentTime() {
  return currentTime;
}

function createTask(name, priority, callback) {
  const now = getCurrentTime();
  const timeout = timeoutForPriorityLevel(priority);
  const expirationTime = now + timeout;

  const task = {
    id: taskIdCounter++,
    name,
    priority,
    priorityName: priorityNames[priority],
    callback,
    createdAt: now,
    timeout,
    expirationTime,
    executed: false
  };

  console.log(`创建任务 #${task.id}: ${task.name}`);
  console.log(`  优先级: ${task.priority} (${task.priorityName})`);
  console.log(`  创建时间: ${task.createdAt}ms`);
  console.log(`  超时时间: ${task.timeout}ms`);
  console.log(`  过期时间: ${task.expirationTime}ms`);

  return task;
}

// 创建5个不同优先级的任务
const tasks = [
  createTask('数据统计', LowPriority, () => console.log('执行：数据统计')),
  createTask('用户点击', UserBlockingPriority, () => console.log('执行：用户点击')),
  createTask('网络请求', NormalPriority, () => console.log('执行：网络请求')),
  createTask('紧急修复', ImmediatePriority, () => console.log('执行：紧急修复')),
  createTask('日志上报', IdlePriority, () => console.log('执行：日志上报'))
];

// ===== 4. 任务队列排序 =====
console.log("\n=== 4. 任务队列按过期时间排序 ===");

// 按过期时间排序（最小堆的简化版）
function sortTasksByExpiration(tasks) {
  return [...tasks].sort((a, b) => a.expirationTime - b.expirationTime);
}

const sortedTasks = sortTasksByExpiration(tasks);
console.log('排序后的任务队列（按过期时间）：');
sortedTasks.forEach((task, index) => {
  console.log(`  ${index + 1}. ${task.name} (过期时间: ${task.expirationTime}ms)`);
});

// ===== 5. 检查任务是否过期 =====
console.log("\n=== 5. 检查任务过期状态 ===");

function isTaskExpired(task) {
  return getCurrentTime() >= task.expirationTime;
}

console.log(`当前时间: ${getCurrentTime()}ms`);
sortedTasks.forEach(task => {
  const expired = isTaskExpired(task);
  const status = expired ? '已过期 ⚠️' : '未过期 ✅';
  console.log(`  ${task.name}: ${status}`);
});

// ===== 6. 模拟时间推移，观察过期状态变化 =====
console.log("\n=== 6. 模拟时间推移 ===");

// 时间推进到 1100ms
currentTime = 1100;
console.log(`\n时间推进到 ${currentTime}ms：`);
sortedTasks.forEach(task => {
  const expired = isTaskExpired(task);
  const status = expired ? '已过期 ⚠️' : '未过期 ✅';
  console.log(`  ${task.name}: ${status} (过期时间: ${task.expirationTime}ms)`);
});

// 时间推进到 1300ms
currentTime = 1300;
console.log(`\n时间推进到 ${currentTime}ms：`);
sortedTasks.forEach(task => {
  const expired = isTaskExpired(task);
  const status = expired ? '已过期 ⚠️' : '未过期 ✅';
  console.log(`  ${task.name}: ${status} (过期时间: ${task.expirationTime}ms)`);
});

// ===== 7. 执行任务（优先执行过期任务） =====
console.log("\n=== 7. 执行任务 ===");

function executeTask(task) {
  if (task.executed) return;

  const expired = isTaskExpired(task);
  const status = expired ? '过期任务，强制执行' : '正常执行';

  console.log(`\n[${status}] 执行任务 #${task.id}: ${task.name}`);
  console.log(`  优先级: ${task.priorityName}`);
  console.log(`  创建时间: ${task.createdAt}ms`);
  console.log(`  当前时间: ${getCurrentTime()}ms`);
  console.log(`  等待时间: ${getCurrentTime() - task.createdAt}ms`);

  task.callback();
  task.executed = true;
}

// 执行所有任务
console.log('\n开始执行任务：');
const tasksToExecute = sortTasksByExpiration(tasks);
tasksToExecute.forEach(task => {
  executeTask(task);
});

// ===== 8. 模拟低优先级任务过期场景 =====
console.log("\n=== 8. 低优先级任务过期场景 ===");

// 重置时间
currentTime = 2000;
taskIdCounter = 1;

// 创建一个低优先级任务
const lowTask = createTask('低优先级任务', LowPriority, () => {
  console.log('终于执行了低优先级任务！');
});

console.log(`\n初始状态（时间 ${currentTime}ms）：`);
console.log(`  任务过期时间: ${lowTask.expirationTime}ms`);
console.log(`  任务状态: ${isTaskExpired(lowTask) ? '已过期' : '未过期'}`);

// 模拟高优先级任务不断插队
console.log('\n模拟高优先级任务不断插队：');
for (let i = 0; i < 5; i++) {
  currentTime += 2000; // 每次前进 2秒
  console.log(`\n时间 ${currentTime}ms：`);
  console.log(`  新的高优先级任务来了！`);
  console.log(`  低优先级任务状态: ${isTaskExpired(lowTask) ? '已过期 ⚠️' : '未过期，继续等待...'}`);

  if (isTaskExpired(lowTask)) {
    console.log(`  ⚠️ 低优先级任务已过期！必须立即执行！`);
    executeTask(lowTask);
    break;
  }
}
```

**运行输出示例：**

```
=== 1. 优先级定义 ===
优先级等级：
  1 - Immediate（立即）
  2 - UserBlocking（用户阻塞）
  3 - Normal（正常）
  4 - Low（低）
  5 - Idle（空闲）

=== 2. 超时时间定义 ===
优先级超时时间：
  Immediate: -1ms
  UserBlocking: 250ms
  Normal: 5000ms
  Low: 10000ms
  Idle: 1073741823ms

=== 3. 创建任务 ===
创建任务 #1: 数据统计
  优先级: 4 (Low（低）)
  创建时间: 1000ms
  超时时间: 10000ms
  过期时间: 11000ms
...

=== 8. 低优先级任务过期场景 ===
时间 12000ms：
  新的高优先级任务来了！
  低优先级任务状态: 已过期 ⚠️
  ⚠️ 低优先级任务已过期！必须立即执行！

[过期任务，强制执行] 执行任务 #1: 低优先级任务
  优先级: Low（低）
  创建时间: 2000ms
  当前时间: 12000ms
  等待时间: 10000ms
终于执行了低优先级任务！
```

---

### 进阶：React源码实现

```javascript
// React Scheduler 源码片段
// packages/scheduler/src/forks/Scheduler.js

// 优先级常量定义
export const ImmediatePriority = 1;
export const UserBlockingPriority = 2;
export const NormalPriority = 3;
export const LowPriority = 4;
export const IdlePriority = 5;

// 超时时间常量
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // 1073741823

// 根据优先级获取超时时间
function timeoutForPriorityLevel(priorityLevel) {
  switch (priorityLevel) {
    case ImmediatePriority:
      return IMMEDIATE_PRIORITY_TIMEOUT;
    case UserBlockingPriority:
      return USER_BLOCKING_PRIORITY_TIMEOUT;
    case IdlePriority:
      return IDLE_PRIORITY_TIMEOUT;
    case LowPriority:
      return LOW_PRIORITY_TIMEOUT;
    case NormalPriority:
    default:
      return NORMAL_PRIORITY_TIMEOUT;
  }
}

// 调度回调函数
function unstable_scheduleCallback(priorityLevel, callback, options) {
  // 获取当前时间
  var currentTime = getCurrentTime();

  // 计算任务开始时间
  var startTime;
  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;
    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  // 根据优先级获取超时时间
  var timeout = timeoutForPriorityLevel(priorityLevel);

  // 计算过期时间
  var expirationTime = startTime + timeout;

  // 创建新任务
  var newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1
  };

  if (startTime > currentTime) {
    // 延迟任务，加入延迟队列
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    // 如果任务队列为空且当前任务是最早的延迟任务
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // 请求延迟调度
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // 立即任务，加入任务队列
    newTask.sortIndex = expirationTime;  // 按过期时间排序
    push(taskQueue, newTask);

    // 请求调度
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}

// 工作循环
function workLoop(hasTimeRemaining, initialTime) {
  var currentTime = initialTime;

  // 检查延迟队列，将到期的延迟任务移到任务队列
  advanceTimers(currentTime);

  // 获取最高优先级任务（最小堆顶部）
  currentTask = peek(taskQueue);

  while (currentTask !== null) {
    // 关键判断：任务未过期 且 时间片用完
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYield())
    ) {
      // 任务未过期，但时间片用完了，退出循环
      break;
    }

    var callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;

      // 检查任务是否过期
      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      // 执行任务回调
      var continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();

      if (typeof continuationCallback === 'function') {
        // 任务返回了延续函数，更新回调
        currentTask.callback = continuationCallback;
      } else {
        // 任务完成，从队列移除
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      // 回调为空，移除任务
      pop(taskQueue);
    }

    // 获取下一个任务
    currentTask = peek(taskQueue);
  }

  // 返回是否还有更多工作
  if (currentTask !== null) {
    return true; // 还有任务，需要继续调度
  } else {
    // 任务队列为空，检查延迟队列
    var firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false; // 没有任务了
  }
}
```

**关键点说明：**

1. **优先级定义**：5个常量，数字越小优先级越高
2. **超时时间映射**：每个优先级对应一个超时时间
3. **过期时间计算**：`expirationTime = startTime + timeout`
4. **任务排序**：按 `expirationTime` 排序（最小堆）
5. **过期判断**：`currentTask.expirationTime <= currentTime`
6. **中断逻辑**：未过期且时间片用完时可中断，过期任务必须执行

---

## 八、【面试必问】

### 问题1："React Scheduler 有几个优先级等级？分别是什么？"

**普通回答（❌ 不出彩）：**

"React Scheduler 有5个优先级等级：Immediate、UserBlocking、Normal、Low、Idle。"

**出彩回答（✅ 推荐）：**

> **React Scheduler 定义了5个优先级等级，从高到低分别是：**
>
> 1. **ImmediatePriority（立即优先级）**：超时时间 -1ms，表示立即过期，用于同步任务如 `flushSync`
>
> 2. **UserBlockingPriority（用户阻塞优先级）**：超时时间 250ms，用于用户交互任务如点击、输入，保证用户体验
>
> 3. **NormalPriority（正常优先级）**：超时时间 5000ms（5秒），用于常规更新如网络请求返回的数据渲染
>
> 4. **LowPriority（低优先级）**：超时时间 10000ms（10秒），用于不紧急的后台任务如数据预取
>
> 5. **IdlePriority（空闲优先级）**：超时时间约12.4天（最大31位有符号整数），用于完全不紧急的任务如日志上报
>
> **设计原理：**
> - 每个优先级对应一个超时时间，任务创建后如果在超时时间内未执行，会被标记为过期任务并立即执行
> - 过期机制防止低优先级任务饥饿，保证即使一直有高优先级任务，低优先级任务最终也会执行
> - 优先级数字越小越重要（1 > 2 > 3 > 4 > 5），这与"第一名最好"的概念一致
>
> **实际应用：**
> - 在 React 19 中，用户点击事件默认使用 UserBlockingPriority，保证 250ms 内响应
> - `startTransition` API 会将更新降级为 LowPriority，让紧急更新优先执行
> - 开发者可以通过 `unstable_scheduleCallback` 手动调度不同优先级的任务

**为什么这个回答出彩？**

1. ✅ 不仅列出了5个优先级，还说明了每个的超时时间和使用场景
2. ✅ 解释了优先级设计的核心原理（过期机制、防饥饿）
3. ✅ 联系了 React 源码的实际应用（flushSync、startTransition）
4. ✅ 展示了对优先级系统的深度理解，而不仅仅是记忆

---

### 问题2："为什么 React Scheduler 需要优先级系统？"

**普通回答（❌ 不出彩）：**

"因为不同的任务重要性不同，需要优先执行重要的任务。"

**出彩回答（✅ 推荐）：**

> **优先级系统解决了三个核心问题：**
>
> 1. **任务调度顺序问题**
>    - 在浏览器主线程中，多个任务同时存在时，必须决定先执行哪个
>    - 没有优先级，只能按 FIFO（先来先服务）执行，可能导致紧急任务被延误
>    - 例如：数据统计任务（耗时100ms）先到达，用户点击事件后到达，用户需要等待110ms才能看到响应
>
> 2. **用户体验保证问题**
>    - 用户交互任务（点击、输入）需要在 250ms 内响应，否则用户感觉卡顿
>    - 通过 UserBlockingPriority（250ms超时），保证用户交互任务优先执行
>    - 低优先级的后台任务（如数据分析）可以延迟执行，不影响用户体验
>
> 3. **任务饥饿问题**
>    - 如果一直有高优先级任务，低优先级任务可能永远得不到执行
>    - 通过超时机制，低优先级任务等待超时后会被提升为最高优先级强制执行
>    - 例如：低优先级任务（10秒超时）等待10秒后，即使有新的高优先级任务也必须先执行它
>
> **与 React 16 之前的区别：**
> - React 16 之前使用递归遍历虚拟 DOM，一旦开始就无法中断，无法实现优先级调度
> - React 16 引入 Fiber 架构，将递归改为循环 + 指针，配合 Scheduler 优先级系统，实现可中断的任务调度
>
> **实际应用场景：**
> - 用户输入搜索框：输入框更新（高优先级）必须快于搜索结果更新（低优先级）
> - 页面滚动：滚动事件响应（高优先级）必须快于懒加载数据渲染（低优先级）
> - 数据大屏：实时数据更新（高优先级）优先于历史数据分析（低优先级）

**为什么这个回答出彩？**

1. ✅ 从问题出发，说明了优先级系统解决的三个核心问题
2. ✅ 对比了 React 16 前后的差异，展示了历史演进
3. ✅ 提供了具体的实际应用场景，而不是抽象概念
4. ✅ 展示了系统性思考，理解了优先级系统在整个 React 架构中的作用

---

## 九、【化骨绵掌】

### 卡片1：优先级是什么？ 🎯

**一句话：** 优先级是给任务打的标签，决定了任务的执行顺序。

**举例：**
```javascript
const task1 = { name: '数据统计', priority: 4 };  // 低优先级
const task2 = { name: '用户点击', priority: 2 };  // 高优先级

// 先执行 task2，再执行 task1
```

**应用：** React Scheduler 通过优先级确保用户交互任务优先于后台任务执行。

---

### 卡片2：5个优先级等级 📊

**一句话：** React 定义了5个优先级等级，数字越小优先级越高。

**举例：**
| 等级 | 名称 | 数值 | 超时时间 |
|------|------|------|---------|
| 最高 | Immediate | 1 | -1ms |
| 高 | UserBlocking | 2 | 250ms |
| 中 | Normal | 3 | 5000ms |
| 低 | Low | 4 | 10000ms |
| 最低 | Idle | 5 | 无限大 |

**应用：** 用户点击事件使用 UserBlockingPriority，数据分析使用 LowPriority。

---

### 卡片3：超时时间的作用 ⏰

**一句话：** 超时时间限定了任务最长等待时间，超时后任务过期并强制执行。

**举例：**
```javascript
const task = {
  priority: LowPriority,
  timeout: 10000,        // 超时 10秒
  createdAt: 1000,
  expirationTime: 11000  // 1000 + 10000
};

// 11秒后，任务过期，必须执行
if (currentTime >= 11000) {
  executeImmediately(task);
}
```

**应用：** 防止低优先级任务永远得不到执行（饥饿问题）。

---

### 卡片4：过期时间计算 🧮

**一句话：** 过期时间 = 创建时间 + 超时时间。

**举例：**
```javascript
// 当前时间 1000ms，创建一个正常优先级任务
const currentTime = 1000;
const timeout = 5000;  // NormalPriority 超时 5秒
const expirationTime = currentTime + timeout;  // 6000ms

// 在 6000ms 之前执行都正常
// 超过 6000ms 就过期了
```

**应用：** Scheduler 根据过期时间判断任务是否需要强制执行。

---

### 卡片5：任务过期 🚨

**一句话：** 任务过期是指当前时间超过了任务的过期时间，过期任务必须立即执行。

**举例：**
```javascript
function isExpired(task) {
  return getCurrentTime() >= task.expirationTime;
}

if (isExpired(task)) {
  // 任务过期，不可中断，必须执行
  executeTask(task);
}
```

**应用：** 过期任务会被提升为最高优先级，保证最终一定会执行。

---

### 卡片6：优先级数字小的优先 🔢

**一句话：** 优先级数字越小，优先级越高（1 > 2 > 3 > 4 > 5）。

**举例：**
```javascript
// 比较两个任务的优先级
function shouldPreempt(newTask, currentTask) {
  return newTask.priority < currentTask.priority;
}

// ImmediatePriority (1) 会抢占 NormalPriority (3)
shouldPreempt({ priority: 1 }, { priority: 3 });  // true
```

**应用：** 调度器根据优先级数字决定任务执行顺序。

---

### 卡片7：防止饥饿机制 🛡️

**一句话：** 通过超时机制，低优先级任务等待超时后会被强制执行，防止永远得不到执行。

**举例：**
```javascript
// 低优先级任务等待 10秒 后过期
const lowTask = {
  priority: LowPriority,
  timeout: 10000
};

// 即使一直有高优先级任务插队
// 10秒后低优先级任务过期，必须执行
```

**应用：** 保证所有任务最终都会被执行，维护系统公平性。

---

### 卡片8：ImmediatePriority 特殊性 ⚡

**一句话：** ImmediatePriority 的超时时间是 -1ms，表示立即过期，用于同步任务。

**举例：**
```javascript
const immediateTask = {
  priority: ImmediatePriority,
  timeout: -1,  // 负数，立即过期
  expirationTime: currentTime + (-1)  // 立即过期
};

// 任务一创建就过期了
isExpired(immediateTask);  // true
```

**应用：** React 的 `flushSync` API 使用 ImmediatePriority 强制同步执行。

---

### 卡片9：UserBlockingPriority 与用户体验 👆

**一句话：** UserBlockingPriority 的 250ms 超时保证了用户交互的快速响应。

**举例：**
```javascript
// 用户点击按钮
onClick={() => {
  // 使用 UserBlockingPriority
  // 必须在 250ms 内响应，否则用户感觉卡顿
  setCount(c => c + 1);
}}
```

**应用：** 人类感知延迟的阈值约为 100-300ms，250ms 是用户体验的关键指标。

---

### 卡片10：优先级在 React 中的应用 ⚛️

**一句话：** React 根据更新来源自动分配优先级，开发者也可以通过 API 手动控制。

**举例：**
```javascript
// 自动分配优先级
onClick={() => setCount(c => c + 1)};  // UserBlockingPriority

useEffect(() => {
  fetch('/api').then(data => setData(data));  // NormalPriority
}, []);

// 手动控制优先级
startTransition(() => {
  setFilteredList(filter(list));  // LowPriority
});

flushSync(() => {
  setUrgentState(value);  // ImmediatePriority
});
```

**应用：** 合理使用优先级 API 可以优化用户体验，避免不必要的卡顿。

---

## 十、【一句话总结】

**优先级定义了5个等级（立即、用户阻塞、正常、低、空闲），每个等级对应不同的超时时间，通过过期机制确保高优先级任务优先执行的同时防止低优先级任务饥饿，是React Scheduler实现可中断调度的基础。**

---

## 附录

### 学习检查清单

- [ ] 能说出 React Scheduler 的5个优先级等级和对应的超时时间
- [ ] 理解优先级数字越小优先级越高的设计
- [ ] 理解过期时间的计算公式：`expirationTime = currentTime + timeout`
- [ ] 理解任务过期的判断逻辑：`currentTime >= expirationTime`
- [ ] 知道过期任务必须立即执行，不可中断
- [ ] 理解超时机制如何防止任务饥饿
- [ ] 能解释为什么 ImmediatePriority 的超时时间是 -1ms
- [ ] 能解释为什么 UserBlockingPriority 的超时时间是 250ms
- [ ] 知道如何在 React 中手动控制优先级（startTransition、flushSync）
- [ ] 理解优先级系统在整个 React Scheduler 中的作用

### 下一步学习建议

1. **时间切片**：了解 Scheduler 如何通过时间切片实现可中断调度
2. **最小堆任务队列**：学习任务队列如何按过期时间排序
3. **Lane 模型**：深入理解 React 协调器的优先级系统
4. **调度循环**：学习 workLoop 如何配合优先级执行任务

### 快速参考卡

**5个优先级速查表：**

| 优先级 | 数值 | 超时 | 使用场景 | React API |
|--------|------|------|---------|-----------|
| Immediate | 1 | -1ms | 同步任务 | flushSync |
| UserBlocking | 2 | 250ms | 用户交互 | onClick, onInput |
| Normal | 3 | 5000ms | 常规更新 | useEffect数据加载 |
| Low | 4 | 10000ms | 后台任务 | startTransition |
| Idle | 5 | 无限 | 日志上报 | - |

**核心公式：**
```
expirationTime = currentTime + timeout
isExpired = currentTime >= expirationTime
```

### 参考资源

- [React Scheduler 源码](https://github.com/facebook/react/tree/main/packages/scheduler)
- [React 官方文档 - Concurrent Features](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react)
- [Scheduler 优先级设计文档](https://github.com/facebook/react/blob/main/packages/scheduler/README.md)
